#!/bin/bash
PROJECT_DIR="$(dirname $(realpath $0))";
SCRIPT_NAME="$(basename $0)"

APP_CONTATINER_NAME="o2-rct_application"
DB_CONTATINER_NAME="o2-rct_database"
# TODO describe rest of path, RCT_USER etc. via env vars pulled during deployment

usage() {
    if [ -n "$1" ]; then
        BORDER_PATTERN="' *'"
        ERROR="$1";
        ERROR_REASON_MESS=" error reason: $ERROR";
        LENGTH=$(expr length "$ERROR_REASON_MESS" / 2 + 2);
        HORIZONTAL_BORDER=$(seq -s' *' $LENGTH| tr -d '[:digit:]');
        # echo $HORIZONTAL_BORDER # TODO 'xdTODO' : examine why uncommenting cause some rabish text in usage printout
        ERROR_MESSAGE_PRINT="
*$HORIZONTAL_BORDER
*$ERROR_REASON_MESS *
*$HORIZONTAL_BORDER
"
    fi

    cat << USAGE >&2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
This script is intended to provide handy functionalities during 
    development, testing and production for building, deployment and managing acquired data.
The script can be run from any location.
The script performs defined tasks sequentially.
Some tasks might or have to be run with dedicated flags.
Tasks are called stages.

Usage:  
        ./$SCRIPT_NAME <STAGES> [<FLAGS>]
            'raw usage of script is for production purpose and is described at the end'
        where STAGES is comma separeted list of stages performed sequentialy. 
        In default behaviour failure of one stage causes stopping pipeline execution, it can be changes via flag --ignore-errors.
        STAGE can be a:
            1. build|build[BUILD_STATGES] - build application (deploys contatiners). By defualt 
                    build stage behaves as docker-compose ... up --build.
                    BUILD_STATGES are colon separated docker-compose tasks like build,up
                Using build stage requires usage of -|--target flag wich specifies one of prod,dev,test.
                e.g.: ./$SCRIPT_NAME build -t dev
                      ./$SCRIPT_NAME build[up] -t dev
            2. stop - stop contatiners                      
            
            3. prune - delete both contatiners, all virtual volumens and virtual network

            4. attach - like docker attach to rct_application

            5. follow - like docker-compose follow

            6. db:export - export db sql definition from pgmodeler design
            7. db:clean | db:truncate - truncate database in db contatiner

            8. dump:make - make dump of current database (in docker contatiner) data, 
                      need option -F|--dump-file <FILE> to specify dump file relative path
                e.g.: ./$SCRIPT_NAME dump -F dump_file
            9. dump:list - make list cached dumps
            10. dump:remove -F|--dump-file <FILE> - remove dump from cache specified by the flag
            11. dump:restore -F|--dump-file <FILE> - restore data from dump specified by the flag
                e.g.: ./$SCRIPT_NAME restore -F dump_file
            12. dump:export -A|--archive-name <FILE> - export cached dump to tar.gz archive specified by the flag
            13. dump:import -A|--archive-name <FILE> - import dumps from tar.gz archvie specified by the flag ito cache

        ! For build, follow, stop, prune stages an additional flag can be specified: -S|--service <SERVICE>,
            witch specify service ($DB_CONTATINER_NAME or $APP_CONTATINER_NAME) which stages are performed for.

        @Deprecated - as the Alice tool RCT production will NOT be handeled with dockers
        Default behaviour of $SCRIPT_NAME (./$SCRIPT_NAME) is build prod it is equivalent to
            ./$SCRIPT_NAME prune,build --target prod
    
$ERROR_MESSAGE_PRINT
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
USAGE

if [ -n "$ERROR" ]; then
    exit 1;
else
    exit 0;
fi;
}

incorrect_stage_err() {
    usage "Incorrect stage: $1";
}

exit_codes_filter() {
    LAST_CMD_EXIT_CODE=$?
    IGNORABLE_CODES=$@
    for ie in $IGNORABLE_CODES; do
        if [ $LAST_CMD_EXIT_CODE -eq $ie ]; then
            return 0;
        fi;
    done
    return $LAST_CMD_EXIT_CODE
}


PREVIOD_USER_LOC=$(pwd);
DOCKER_DIR="$PROJECT_DIR/docker";
MAIN_DOCKER_COMPOSE_YML="$DOCKER_DIR/docker-compose.yml"
DOCKER_COMP_CMD="docker compose -f $MAIN_DOCKER_COMPOSE_YML --project-directory $PROJECT_DIR ";

# defualt behaviour => dettached production built
if [[  $# -eq 0 ]]; then
    STAGES='prune build'
    TARGET='prod'
else
    STAGES=$(echo $1 | tr ',' ' ');
    shift 1;
    while [[ $# -gt 0 ]]; do
        case $1 in 
            -h|--help)
                usage;
            ;;
            -t|--target)
                TARGET=$2;
                shift 2;
                ;;
            -S|--service)
                SERVICES="$SERVICES $(echo $2 | tr ',' ' ')";
                shift 2;
                ;;
            -m|--mock)
                MOCK_DB=true;
                shift 1;
                ;;
            -a|--attach)
                ATTACH_TO_APP=true;
                shift 1;
                ;;
            -F|--dump-file)
                DUMP_FILE=$2;
                shift 2;
                ;;
            -A|--archive-name)
                DUMPS_ARCHIVE_NAME=$2;
                shift 2;
                ;;
            --ignore-errors)
                IGNORE_STAGE_ERRORS='true';
                shift 1;
            ;;
            
            *)
                usage "Incorrect flag: $1"
            ;;
        esac
    done
fi

MOCK_DB=${MOCK_DB:-false};
export MOCK_DB;


build() {
    mkdir -p $PROJECT_DIR/security;
    CACHE_DIR="$PROJECT_DIR/database/cache";
    mkdir -p $CACHE_DIR;
    ORDER=$1;
    case $TARGET in 
        dev)
            $DOCKER_COMP_CMD \
                -f $DOCKER_DIR/docker-compose-dev.yml \
                -f $DOCKER_DIR/docker-compose-expose.yml \
                $ORDER $OTHER_OPTS $SERVICES;
            if [ "$ATTACH_TO_APP" = 'true' ]; then
                docker attach $APP_CONTATINER_NAME;
            fi
        ;;

        prod)
            $DOCKER_COMP_CMD \
                -f $DOCKER_DIR/docker-compose-prod.yml \
                -f $DOCKER_DIR/docker-compose-expose.yml \
                $ORDER $OTHER_OPTS $SERVICES;
        ;;

        test)
            mkdir -p $PROJECT_DIR/reports;
            $DOCKER_COMP_CMD \
                -f $DOCKER_DIR/docker-compose-test.yml \
                up --build --abort-on-container-exit $OTHER_OPTS;
        ;;
        *)
            usage "Incorrect build target: $TARGET";
        ;;
    esac
}


for stage in $STAGES; do
    RCT_DATABASE='rct-db';
    RCT_USER='postgres';

    echo " *** do $stage";
    case $stage in
        prune)
            $DOCKER_COMP_CMD rm --stop --force -v $SERVICES;
        ;;

        db*)
            DB_CMD=$(echo ${stage#db:});
            case $DB_CMD in
                export)
                    $PROJECT_DIR/database/setup-db.sh --only-export;
                ;;
                clean | truncate)
                    docker exec $DB_CONTATINER_NAME psql -U $RCT_USER -d $RCT_DATABASE -f "database/utils/delete-data.sql";
                ;;
                *)
                    incorrect_stage_err $stage;
                ;;
            esac
        ;;
        
        dump*)
            DUMP_CMD=$(echo ${stage#dump:});
            DUMPS_DIR="$PROJECT_DIR/database/cache/dumps";
            mkdir -p "$DUMPS_DIR";
            DUMP_PATH="$DUMPS_DIR/$DUMP_FILE";
            CONTATINER_DUMP_PATH="/postgres/run/database/cache/dumps/$DUMP_FILE";

            case $DUMP_CMD in
                make)
                    if [ -z "$DUMP_FILE" ]; then
                        usage "Dump file unspecified, use flag -F|--dump-file <FILE>";
                    fi
                    if [ -f "$DUMP_PATH" ]; then
                        echo "Do you want to overwrite existing file $DUMP_FILE :  y|[n] ?";
                        read permission;
                        if [[ "$permission" =~ ^y|Y|yes|Yes$ ]]; then
                            echo "continuing";
                        else 
                            DO_NOT_PERFORME_WHILE_FILE_EXISTS="true";
                            echo 'making dump canceled';
                        fi
                    fi

                    if [ -z $DO_NOT_PERFORME_WHILE_FILE_EXISTS ]; then
                        docker exec $DB_CONTATINER_NAME mkdir -p $(dirname $CONTATINER_DUMP_PATH) \
                        && docker exec $DB_CONTATINER_NAME \
                            pg_dump --data-only --format=tar -d $RCT_DATABASE -U $RCT_USER --file="$CONTATINER_DUMP_PATH";
                    fi
                ;;

                list)
                    ls -lthR "$DUMPS_DIR";
                ;;

                tree)
                    tree $DUMPS_DIR -t;
                ;;

                browse)
                    DUMPS_HTML="$PROJECT_DIR/reports/dumps.html";
                    tree -t $DUMPS_DIR -H $DUMPS_DIR -o $DUMPS_HTML;
                    x-www-browser $DUMPS_HTML &
                ;;

                restore)
                    if [ -z "$DUMP_FILE" ]; then
                        usage "Dump file name unspecified, use flag -F|--dump-file <FILE>";
                    fi
                    docker cp "$PROJECT_DIR/database/utils/delete-data.sql" "$DB_CONTATINER_NAME:/postgres/run/" \
                    && docker exec $DB_CONTATINER_NAME psql -U $RCT_USER -d $RCT_DATABASE -f "database/utils/delete-data.sql" \
                    && docker exec $DB_CONTATINER_NAME pg_restore --data-only -U $RCT_USER -d $RCT_DATABASE $CONTATINER_DUMP_PATH;
                ;;

                remove)
                    if [ -z "$DUMP_FILE" ]; then
                        usage "dump file unspecified, use flag -F|--dump-file <FILE>";
                    fi 
                    rm $DUMP_PATH;
                ;;

                export)
                    tar -c -f $PREVIOD_USER_LOC/$DUMPS_ARCHIVE_NAME -C $DUMPS_DIR .;
                ;;

                import)
                    tar xvf $PREVIOD_USER_LOC/$DUMPS_ARCHIVE_NAME -C $DUMPS_DIR;
                ;;

                *)
                    incorrect_stage_err $stage;
                ;;
            esac
        ;;

        build*)
            BUILD_STAGES=$(echo ${stage#build} | sed -E "s/(\[|\:|\])/ /g");
            BUILD_STAGES=$(echo $BUILD_STAGES | sed -E "s/(^[[:space:]]*)|([[:space:]]*$)//g");
            if [ -z "$BUILD_STAGES" ]; then
                echo 'default build[build,up]; up in detached mode';
                BUILD_STAGES="build up";
            fi
            echo $BUILD_STAGES;
            for bs in $BUILD_STAGES; do
                echo "*** *** do build : $bs";
                if [ "$bs" == 'up' ]; then
                    bs="up --detach";
                fi
                build "$bs";
            done
        ;;

        attach)
            docker attach $APP_CONTATINER_NAME || exit_codes_filter 130;
        ;;

        follow)
            $DOCKER_COMP_CMD logs --follow $OTHER_OPTS $SERVICES || exit_codes_filter 1;
        ;;

        stop)
            $DOCKER_COMP_CMD stop $OTHER_OPTS $SERVICES;
        ;;

        *)
            incorrect_stage_err $stage
        ;;
    esac

    CURRENT_STAGE_STATUS_CODE=$?
    if [ $CURRENT_STAGE_STATUS_CODE -ne 0 ]; then
        echo "stage $stage ended with code: $CURRENT_STAGE_STATUS_CODE"
        if [ -z $IGNORE_STAGE_ERRORS ]; then
            exit $CURRENT_STAGE_STATUS_CODE;
        fi;
    fi;
done


cd $PREVIOD_USER_LOC;
