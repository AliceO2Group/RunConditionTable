#!/bin/bash
echo $@

PROJECT_DIR="$(dirname $(realpath $0))";
SCRIPT_NAME="$(basename $0)"

DEV_MODE=dev
TEST_MODE=test
APP_CONTAINER_NAME_BASE="o2rct_application"
APP_CONTAINERS_OPT="$APP_CONTAINER_NAME_BASE-([$DEV_MODE|$TEST_MODE])"

DB_CONTAINER_NAME_BASE="o2rct_database"
DP_CONTAINERS_OPT="$DB_CONTAINER_NAME-($DEV_MODE|$TEST_MODE))"

ITWILLBEDELETED="!(It will be deleted)"

# TODO describe rest of path, RCT_USER etc. via env vars pulled during deployment

usage() {
    if [ -n "$1" ]; then
        BORDER_PATTERN="' *'"
        ERROR="$1";
        ERROR_REASON_MESS=" error reason: $ERROR";
        LENGTH=$(expr length "$ERROR_REASON_MESS" / 2 + 2);
        HORIZONTAL_BORDER=$(seq -s' *' $LENGTH| tr -d '[:digit:]');
        # echo $HORIZONTAL_BORDER # TODO 'xdTODO' : examine why uncommenting cause some rabish text in usage printout
        ERROR_MESSAGE_PRINT="
*$HORIZONTAL_BORDER
*$ERROR_REASON_MESS *
*$HORIZONTAL_BORDER
"
    fi

    cat << USAGE >&2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
This script is intended to provide handy functionalities during 
    development, testing for building, deployment and managing acquired data.
The script can be run from any location.
The script performs defined tasks sequentially.
Some tasks might or have to be run with dedicated flags.
Tasks are called stages.

Usage:  
        ./$SCRIPT_NAME <STAGES> [<FLAGS>]
        where STAGES is comma separeted list of stages performed sequentialy. 
        In default behaviour failure of one stage causes stopping pipeline execution, it can be changes via flag --ignore-errors.
        Using moste of stages requires TARGET to be specified (default dev). It can be specified via flag -t|--target as test as well as via exporting env var TARGET;
        Each stage is performed within the context of target.
        Using conatiners build as dev and test is separted and can be performed in parallel.

        Is seems that there is one case of target test, just something like ./rctmake run --target test.

        STAGE can be a:
            1. run|run[RUN_SUBSTATGES] - run application (deploys containers). By defualt 
                    run stage behaves as docker-compose ... up --build.
                    RUN_SUBSTATGES are colon separated docker-compose tasks like run,create,up,...
                e.g.: ./$SCRIPT_NAME run -t dev
                      ./$SCRIPT_NAME run[up] -t test
            2. stop - stop containers                      
            
            3. prune - delete containers, all virtual volumens and virtual network

            4. app:attach - like docker attach to $APP_CONTAINERS_OPT
            5. app:ip - retrive ip of $DB_CONTAINERS_OPT

            5. follow - like docker-compose follow

            6. db:export - export db sql definition from pgmodeler design $ITWILLBEDELETED
            7. db:clean | db:truncate - truncate database in db container
            8. db:ip - print db container ipv4 address

            10. dump:(make|mk) - make dump of current database (in docker container) data, 
                      need option -F|--dump-file <FILE> to specify dump file relative path
                e.g.: ./$SCRIPT_NAME dump -F dump_file
            11. dump:(list|ls) - print list cached dumps
            12. dump:tree - print tree of cached dumps
            13. dump:(remove|rm) -F|--dump-file <FILE> - remove dump from cache specified by the flag
            14. dump:(restore|re) -F|--dump-file <FILE> - restore data from dump specified by the flag
                e.g.: ./$SCRIPT_NAME restore -F dump_file
            15. dump:(export|ex) -A|--archive-name <FILE> - export cached dump to tar.gz archive specified by the flag
            16. dump:(import|im) -A|--archive-name <FILE> - import dumps from tar.gz archvie specified by the flag ito cache

        ! An additional -S|--service <SERVICE> flag can be specified for run, follow, stop and prune stages.
        <SERVICE> $APP_CONTAINERS_OPT or $DB_CONTAINERS_OPT is the name of the service the stages are performed for.

        ! Production - Deprecated - as the Alice tool, RCT production will NOT be handeled with the use of dockers
    
$ERROR_MESSAGE_PRINT
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
USAGE

if [ -n "$ERROR" ]; then
    exit 1;
else
    exit 0;
fi;
}

incorrect_stage_err() {
    usage "Incorrect stage: $1";
}

exit_codes_filter() {
    LAST_CMD_EXIT_CODE=$?
    IGNORABLE_CODES=$@
    for ie in $IGNORABLE_CODES; do
        if [ $LAST_CMD_EXIT_CODE -eq $ie ]; then
            return 0;
        fi;
    done
    return $LAST_CMD_EXIT_CODE
}


PREVIOD_USER_LOC=$(pwd);
DOCKER_DIR="$PROJECT_DIR/docker";
MAIN_DOCKER_COMPOSE_YML="$DOCKER_DIR/docker-compose.yml"


if [[  $# -eq 0 ]]; then
    usage 'no option specfied'
else
    STAGES=$(echo $1 | tr ',' ' ');
    shift 1;
    while [[ $# -gt 0 ]]; do
        case $1 in 
            -h|--help)
                usage;
            ;;
            -t|--target)
                export TARGET=$2;
                shift 2;
                ;;
            -S|--service)
                SERVICES="$SERVICES $(echo $2 | tr ',' ' ')";
                shift 2;
                ;;
            -m|--mock)
                MOCK_DB=true;
                shift 1;
                ;;
            -F|--dump-file)
                DUMP_FILE=$2;
                shift 2;
                ;;
            -A|--archive-name)
                DUMPS_ARCHIVE_NAME=$2;
                shift 2;
                ;;
            --ignore-errors)
                IGNORE_STAGE_ERRORS='true';
                shift 1;
            ;;
            -Y)
                ALL_PERMISSIONS='true';
                shift 1;
            ;;
            --db-expose)
                DB_EXPOSED_PORT=$2;
                shift 2;
            ;;
            *)
                usage "Incorrect flag: $1"
            ;;
        esac
    done
fi

export TARGET=${TARGET:-dev}
export APP_CONTAINER_NAME="o2rct_application-$TARGET"
export DB_CONTAINER_NAME="o2rct_database-$TARGET"

DOCKER_COMP_CMD_NO_ENV="docker compose -p $TARGET-o2rct 
                    -f $MAIN_DOCKER_COMPOSE_YML 
                    -f $DOCKER_DIR/docker-compose-$TARGET.yml 
                    --env-file "$DOCKER_DIR/$TARGET.env" 
                    --project-directory $PROJECT_DIR";
DOCKER_COMP_CMD="$DOCKER_COMP_CMD_NO_ENV -f $DOCKER_DIR/docker-compose-env.yml"

MOCK_DB=${MOCK_DB:-false};
export MOCK_DB;


run() {
    SUBCMD_AND_FLAGS="$@";
    mkdir -p $PROJECT_DIR/security;
    CACHE_DIR="$PROJECT_DIR/database/cache";
    mkdir -p $CACHE_DIR;

   
    case $TARGET in 
        dev)
            export DB_EXPOSED_PORT;
            OPTIONAL_DB_EXPOSE=$(if [ -n "$DB_EXPOSED_PORT"  ]; then echo "-f $DOCKER_DIR/docker-compose-db-expose.yml"; fi);

            $DOCKER_COMP_CMD \
                -f "$DOCKER_DIR/docker-compose-volumes.yml" $OPTIONAL_DB_EXPOSE \
                $SUBCMD_AND_FLAGS $SERVICES;
        ;;

        test)
            mkdir -p $PROJECT_DIR/reports;
            $DOCKER_COMP_CMD \
                $SUBCMD_AND_FLAGS;
        ;;
        *)
            usage "Incorrect run target: $TARGET";
        ;;
    esac
}


for stage in $STAGES; do
    RCT_DATABASE='rct-db';
    RCT_USER='postgres';

    echo " *** do $stage";
    case $stage in
        prune)
            $DOCKER_COMP_CMD_NO_ENV rm --stop --force -v $SERVICES;
        ;;

        run*)
            RUN_SUBSTATGES=$(echo ${stage#run} | sed -E "s/(\[|\:|\])/ /g");
            RUN_SUBSTATGES=$(echo $RUN_SUBSTATGES | sed -E "s/(^[[:space:]]*)|([[:space:]]*$)//g");
            if [ -z "$RUN_SUBSTATGES" ]; then
                echo 'default run[run,create,up]; up in detached mode';
                RUN_SUBSTATGES="run create up";
            fi
            echo $RUN_SUBSTATGES;
            for rs in $RUN_SUBSTATGES; do
                echo "*** *** do run : $rs";
                if [ "$rs" == 'up' ]; then
                    if [ "$TARGET" = "$DEV_MODE" ]; then 
                        rs="up --detach";
                    elif [ "$TARGET" = "$TEST_MODE" ]; then
                        rs="up --abort-on-container-exit";
                    fi;
                fi;
                run "$rs";
            done
        ;;

        follow)
            $DOCKER_COMP_CMD logs --follow $SERVICES || exit_codes_filter 1;
        ;;

        stop)
            $DOCKER_COMP_CMD stop $SERVICES;
        ;;

        db*)
            DB_CMD=$(echo ${stage#db:});
            case $DB_CMD in
                export)
                    $PROJECT_DIR/database/setup-db.sh --only-export;
                ;;
                clean | truncate)
                    docker cp "$PROJECT_DIR/database/utils/delete-data.sql" "$DB_CONTAINER_NAME:/postgres/run/delete-data.sql" \
                    && docker exec $DB_CONTAINER_NAME psql -U $RCT_USER -d $RCT_DATABASE -f "/postgres/run/delete-data.sql";
                ;;
                
                ip)
                    docker inspect $DB_CONTAINER_NAME -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'
                ;;
                counts)
                    docker exec $DB_CONTAINER_NAME /docker-entrypoint-initdb.d/utils/print-data.sh
                ;;
                *)
                    incorrect_stage_err $stage;
                ;;
            esac
        ;;

        app*)
            APP_CMD=$(echo ${stage#app:});
            case $APP_CMD in
                attach)
                    docker attach $APP_CONTAINER_NAME || exit_codes_filter 130;
                ;;
                ip)
                    docker inspect $APP_CONTAINER_NAME -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'
                ;;
                *)
                    incorrect_stage_err $stage;
                ;;
            esac
        ;;
        
        dump*)
            DUMP_CMD=$(echo ${stage#dump:});
            DUMPS_DIR="$PROJECT_DIR/database/cache/dumps";
            mkdir -p "$DUMPS_DIR";
            DUMP_PATH="$DUMPS_DIR/$DUMP_FILE";
            CONTAINER_DUMP_PATH="/postgres/run/database/cache/dumps/$DUMP_FILE";

            case $DUMP_CMD in
                make|mk)
                    if [ -z "$DUMP_FILE" ]; then
                        usage "Dump file unspecified, use flag -F|--dump-file <FILE>";
                    fi
                    if [ -f "$DUMP_PATH" ]; then
                        if [[ "$ALL_PERMISSIONS" != 'true' ]]; then
                            echo "Do you want to overwrite existing file $DUMP_PATH :  y|[n] ?";
                            read permission;
                        
                            if [[ "$ALL_PERMISSIONS" = 'true' ]] || [[ "$permission" =~ ^y|Y|yes|Yes$ ]]; then
                                echo "continuing";
                            else 
                                DO_NOT_PERFORME_WHILE_FILE_EXISTS="true";
                                echo 'making dump canceled';
                            fi
                        fi
                    fi

                    if [ -z $DO_NOT_PERFORME_WHILE_FILE_EXISTS ]; then
                        docker exec $DB_CONTAINER_NAME mkdir -p $(dirname $CONTAINER_DUMP_PATH) \
                        && docker exec $DB_CONTAINER_NAME \
                            pg_dump --data-only --format=tar -d $RCT_DATABASE -U $RCT_USER --file="$CONTAINER_DUMP_PATH";
                    fi
                ;;

                list|ls)
                    ls -lthR "$DUMPS_DIR";
                ;;

                tree)
                    tree $DUMPS_DIR -t;
                ;;

                browse|br)
                    DUMPS_HTML="$PROJECT_DIR/reports/dumps.html";
                    tree -t $DUMPS_DIR -H $DUMPS_DIR -o $DUMPS_HTML;
                    x-www-browser $DUMPS_HTML &
                ;;

                restore|re)
                    if [ -z "$DUMP_FILE" ]; then
                        usage "Dump file name unspecified, use flag -F|--dump-file <FILE>";
                    fi
                    docker cp "$PROJECT_DIR/database/utils/delete-data.sql" "$DB_CONTAINER_NAME:/postgres/run/delete-data.sql" \
                    && docker exec $DB_CONTAINER_NAME psql -U $RCT_USER -d $RCT_DATABASE -f "/postgres/run/delete-data.sql" \
                    && docker exec $DB_CONTAINER_NAME pg_restore --data-only -U $RCT_USER -d $RCT_DATABASE $CONTAINER_DUMP_PATH;
                ;;

                migrate|mg)
                    if [ -z "$DUMP_FILE" ]; then
                        usage "Dump file name unspecified, use flag -F|--dump-file <FILE>";
                    fi
                    if ! $PROJECT_DIR/rctmake dump:restore -F $DUMP_FILE; then
                        docker exec $DB_CONTAINER_NAME /docker-entrypoint-initdb.d/utils/print-data.sh

                        echo Is it ok?
                        echo "What do you want to do with file: $DUMP_PATH  ?";
                        echo "Cancel operation | Replace | As new File";
                        echo  " : [c]|r|n" 
                        read opt;
                        if [[ "$opt" =~ ^r$ ]]; then
                            $PROJECT_DIR/rctmake dump:make -F $DUMP_FILE -Y
                        elif [[ "$opt" =~ ^n$ ]]; then
                            $PROJECT_DIR/rctmake dump:make -F $DUMP_FILE.migrated
                        else 
                            exit 0;
                        fi
                    else
                        echo nothing to do;
                    fi
                ;;

                remove|rm)
                    if [ -z "$DUMP_FIL" ]; then
                        usage "dump file unspecified, use flag -F|--dump-file <FILE>";
                    fi 
                    rm $DUMP_PATH;
                ;;

                export|ex)
                    tar -c -f $PREVIOD_USER_LOC/$DUMPS_ARCHIVE_NAME -C $DUMPS_DIR .;
                ;;

                import|im)
                    tar xvf $PREVIOD_USER_LOC/$DUMPS_ARCHIVE_NAME -C $DUMPS_DIR;
                ;;

                *)
                    incorrect_stage_err $stage;
                ;;
            esac
        ;;
        *)
            incorrect_stage_err $stage
        ;;
    esac

    CURRENT_STAGE_STATUS_CODE=$?
    if [ $CURRENT_STAGE_STATUS_CODE -ne 0 ]; then
        echo "stage $stage ended with code: $CURRENT_STAGE_STATUS_CODE"
        if [ -z $IGNORE_STAGE_ERRORS ]; then
            exit $CURRENT_STAGE_STATUS_CODE;
        fi;
    fi;
done


cd $PREVIOD_USER_LOC;
