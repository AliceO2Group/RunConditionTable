#!/bin/bash
echo $@

PROJECT_DIR="$(dirname $(realpath $0))";
SCRIPT_NAME="$(basename $0)"

DEV_MODE=dev
TEST_MODE=test
APP_CONTAINER_NAME_BASE="o2rct_application"
DB_CONTAINER_NAME_BASE="o2rct_database"

# TODO describe rest of path, RCT_USER etc. via env vars pulled during deployment

usage() {
    if [ -n "$1" ]; then
        BORDER_PATTERN="' *'"
        ERROR="$1";
        ERROR_REASON_MESS=" error reason: $ERROR";
        LENGTH=$(expr length "$ERROR_REASON_MESS" / 2 + 2);
        HORIZONTAL_BORDER=$(seq -s' *' $LENGTH| tr -d '[:digit:]');
        # echo $HORIZONTAL_BORDER # TODO 'xdTODO' : examine why uncommenting cause some rabish text in usage printout
        ERROR_MESSAGE_PRINT="
*$HORIZONTAL_BORDER
*$ERROR_REASON_MESS *
*$HORIZONTAL_BORDER
"
    fi

    cat << USAGE >&2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
This script is intended to provide handy functionalities during 
    development, testing and production for building, deployment and managing acquired data.
The script can be run from any location.
The script performs defined tasks sequentially.
Some tasks might or have to be run with dedicated flags.
Tasks are called stages.

Usage:  
        ./$SCRIPT_NAME <STAGES> [<FLAGS>]
            'raw usage of script is for production purpose and is described at the end'
        where STAGES is comma separeted list of stages performed sequentialy. 
        In default behaviour failure of one stage causes stopping pipeline execution, it can be changes via flag --ignore-errors.
        STAGE can be a:
            1. build|build[BUILD_STATGES] - build application (deploys containers). By defualt 
                    build stage behaves as docker-compose ... up --build.
                    BUILD_STATGES are colon separated docker-compose tasks like build,up
                Using build stage requires usage of -|--target flag wich specifies one of prod,dev,test.
                e.g.: ./$SCRIPT_NAME build -t dev
                      ./$SCRIPT_NAME build[up] -t dev
            2. stop - stop containers                      
            
            3. prune - delete both containers, all virtual volumens and virtual network

            4. attach - like docker attach to rct_application

            5. follow - like docker-compose follow

            6. db:export - export db sql definition from pgmodeler design
            7. db:clean | db:truncate - truncate database in db container
            8. db:ip - print db container ipv4 address

            9. app:ip - print app container ipv4 address

            10. dump:(make|mk) - make dump of current database (in docker container) data, 
                      need option -F|--dump-file <FILE> to specify dump file relative path
                e.g.: ./$SCRIPT_NAME dump -F dump_file
            11. dump:(list|ls) - print list cached dumps
            12. dump:tree - print tree of cached dumps
            13. dump:(remove|rm) -F|--dump-file <FILE> - remove dump from cache specified by the flag
            14. dump:(restore|re) -F|--dump-file <FILE> - restore data from dump specified by the flag
                e.g.: ./$SCRIPT_NAME restore -F dump_file
            15. dump:(export|ex) -A|--archive-name <FILE> - export cached dump to tar.gz archive specified by the flag
            16. dump:(import|im) -A|--archive-name <FILE> - import dumps from tar.gz archvie specified by the flag ito cache

        ! An additional -S|--service <SERVICE> flag can be specified for build, follow, stop and prune stages.
        <SERVICE> ($DB_CONTAINER_NAME_BASE-([$DEV_MODE|$TEST_MODE]) or $APP_CONTAINER_NAME-($DEV_MODE|$TEST_MODE)) is the name of the service the stages are performed for.

        ! Production - Deprecated - as the Alice tool, RCT production will NOT be handeled with the use of dockers
    
$ERROR_MESSAGE_PRINT
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
USAGE

if [ -n "$ERROR" ]; then
    exit 1;
else
    exit 0;
fi;
}

incorrect_stage_err() {
    usage "Incorrect stage: $1";
}

exit_codes_filter() {
    LAST_CMD_EXIT_CODE=$?
    IGNORABLE_CODES=$@
    for ie in $IGNORABLE_CODES; do
        if [ $LAST_CMD_EXIT_CODE -eq $ie ]; then
            return 0;
        fi;
    done
    return $LAST_CMD_EXIT_CODE
}


PREVIOD_USER_LOC=$(pwd);
DOCKER_DIR="$PROJECT_DIR/docker";
MAIN_DOCKER_COMPOSE_YML="$DOCKER_DIR/docker-compose.yml"


if [[  $# -eq 0 ]]; then
    usage 'no option specfied'
else
    STAGES=$(echo $1 | tr ',' ' ');
    shift 1;
    while [[ $# -gt 0 ]]; do
        case $1 in 
            -h|--help)
                usage;
            ;;
            -t|--target)
                export TARGET=$2;
                shift 2;
                ;;
            -S|--service)
                SERVICES="$SERVICES $(echo $2 | tr ',' ' ')";
                shift 2;
                ;;
            -m|--mock)
                MOCK_DB=true;
                shift 1;
                ;;
            -F|--dump-file)
                DUMP_FILE=$2;
                shift 2;
                ;;
            -A|--archive-name)
                DUMPS_ARCHIVE_NAME=$2;
                shift 2;
                ;;
            --ignore-errors)
                IGNORE_STAGE_ERRORS='true';
                shift 1;
            ;;
            -Y)
                ALL_PERMISSIONS='true';
                shift 1;
            ;;
            --db-expose)
                DB_EXPOSED_PORT=$2;
                shift 2;
            ;;
            *)
                usage "Incorrect flag: $1"
            ;;
        esac
    done
fi

export TARGET=${TARGET:-dev}
export APP_CONTAINER_NAME="o2rct_application-$TARGET"
export DB_CONTAINER_NAME="o2rct_database-$TARGET"

DOCKER_COMP_CMD_NO_ENV="docker compose -p $TARGET-o2rct 
                    -f $MAIN_DOCKER_COMPOSE_YML 
                    -f $DOCKER_DIR/docker-compose-$TARGET.yml 
                    --env-file "$DOCKER_DIR/$TARGET.env" 
                    --project-directory $PROJECT_DIR";
DOCKER_COMP_CMD="$DOCKER_COMP_CMD_NO_ENV -f $DOCKER_DIR/docker-compose-env.yml"

MOCK_DB=${MOCK_DB:-false};
export MOCK_DB;


build() {
    SUBCMD_AND_FLAGS="$@";
    mkdir -p $PROJECT_DIR/security;
    CACHE_DIR="$PROJECT_DIR/database/cache";
    mkdir -p $CACHE_DIR;

   
    case $TARGET in 
        dev)
            export DB_EXPOSED_PORT;
            OPTIONAL_DB_EXPOSE=$(if [ -n "$DB_EXPOSED_PORT"  ]; then echo "-f $DOCKER_DIR/docker-compose-db-expose.yml"; fi);

            $DOCKER_COMP_CMD \
                -f "$DOCKER_DIR/docker-compose-volumes.yml" $OPTIONAL_DB_EXPOSE \
                $SUBCMD_AND_FLAGS $SERVICES;
        ;;

        test)
            mkdir -p $PROJECT_DIR/reports;
            $DOCKER_COMP_CMD \
                $SUBCMD_AND_FLAGS;
        ;;
        *)
            usage "Incorrect build target: $TARGET";
        ;;
    esac
}


for stage in $STAGES; do
    RCT_DATABASE='rct-db';
    RCT_USER='postgres';

    echo " *** do $stage";
    case $stage in
        prune)
            $DOCKER_COMP_CMD_NO_ENV rm --stop --force -v $SERVICES;
        ;;

        build*)
            BUILD_STAGES=$(echo ${stage#build} | sed -E "s/(\[|\:|\])/ /g");
            BUILD_STAGES=$(echo $BUILD_STAGES | sed -E "s/(^[[:space:]]*)|([[:space:]]*$)//g");
            if [ -z "$BUILD_STAGES" ]; then
                echo 'default build[build,create,up]; up in detached mode';
                BUILD_STAGES="build create up";
            fi
            echo $BUILD_STAGES;
            for bs in $BUILD_STAGES; do
                echo "*** *** do build : $bs";
                if [ "$bs" == 'up' ]; then
                    if [ "$TARGET" = "$DEV_MODE" ]; then 
                        bs="up --detach";
                    elif [ "$TARGET" = "$TEST_MODE" ]; then
                        bs="up --abort-on-container-exit";
                    fi;
                fi;
                build "$bs";
            done
        ;;

        attach)
            docker attach $APP_CONTAINER_NAME || exit_codes_filter 130;
        ;;

        follow)
            $DOCKER_COMP_CMD logs --follow $SERVICES || exit_codes_filter 1;
        ;;

        stop)
            $DOCKER_COMP_CMD stop $SERVICES;
        ;;

        db*)
            DB_CMD=$(echo ${stage#db:});
            case $DB_CMD in
                export)
                    $PROJECT_DIR/database/setup-db.sh --only-export;
                ;;
                clean | truncate)
                    docker cp "$PROJECT_DIR/database/utils/delete-data.sql" "$DB_CONTAINER_NAME:/postgres/run/delete-data.sql" \
                    && docker exec $DB_CONTAINER_NAME psql -U $RCT_USER -d $RCT_DATABASE -f "/postgres/run/delete-data.sql";
                ;;
                
                ip)
                    docker inspect $DB_CONTAINER_NAME -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'
                ;;
                counts)
                    docker exec $DB_CONTAINER_NAME /docker-entrypoint-initdb.d/utils/print-data.sh
                ;;
                *)
                    incorrect_stage_err $stage;
                ;;
            esac
        ;;

        app*)
            APP_CMD=$(echo ${stage#app:});
            case $APP_CMD in
                ip)
                    docker inspect $APP_CONTAINER_NAME -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'
                ;;
                *)
                    incorrect_stage_err $stage;
                ;;
                *)
                    incorrect_stage_err $stage
                ;;
            esac
        ;;
        
        dump*)
            DUMP_CMD=$(echo ${stage#dump:});
            DUMPS_DIR="$PROJECT_DIR/database/cache/dumps";
            mkdir -p "$DUMPS_DIR";
            DUMP_PATH="$DUMPS_DIR/$DUMP_FILE";
            CONTAINER_DUMP_PATH="/postgres/run/database/cache/dumps/$DUMP_FILE";

            case $DUMP_CMD in
                make|mk)
                    if [ -z "$DUMP_FILE" ]; then
                        usage "Dump file unspecified, use flag -F|--dump-file <FILE>";
                    fi
                    if [ -f "$DUMP_PATH" ]; then
                        if [[ "$ALL_PERMISSIONS" != 'true' ]]; then
                            echo "Do you want to overwrite existing file $DUMP_PATH :  y|[n] ?";
                            read permission;
                        
                            if [[ "$ALL_PERMISSIONS" = 'true' ]] || [[ "$permission" =~ ^y|Y|yes|Yes$ ]]; then
                                echo "continuing";
                            else 
                                DO_NOT_PERFORME_WHILE_FILE_EXISTS="true";
                                echo 'making dump canceled';
                            fi
                        fi
                    fi

                    if [ -z $DO_NOT_PERFORME_WHILE_FILE_EXISTS ]; then
                        docker exec $DB_CONTAINER_NAME mkdir -p $(dirname $CONTAINER_DUMP_PATH) \
                        && docker exec $DB_CONTAINER_NAME \
                            pg_dump --data-only --format=tar -d $RCT_DATABASE -U $RCT_USER --file="$CONTAINER_DUMP_PATH";
                    fi
                ;;

                list|ls)
                    ls -lthR "$DUMPS_DIR";
                ;;

                tree)
                    tree $DUMPS_DIR -t;
                ;;

                browse|br)
                    DUMPS_HTML="$PROJECT_DIR/reports/dumps.html";
                    tree -t $DUMPS_DIR -H $DUMPS_DIR -o $DUMPS_HTML;
                    x-www-browser $DUMPS_HTML &
                ;;

                restore|re)
                    if [ -z "$DUMP_FILE" ]; then
                        usage "Dump file name unspecified, use flag -F|--dump-file <FILE>";
                    fi
                    docker cp "$PROJECT_DIR/database/utils/delete-data.sql" "$DB_CONTAINER_NAME:/postgres/run/delete-data.sql" \
                    && docker exec $DB_CONTAINER_NAME psql -U $RCT_USER -d $RCT_DATABASE -f "/postgres/run/delete-data.sql" \
                    && docker exec $DB_CONTAINER_NAME pg_restore --data-only -U $RCT_USER -d $RCT_DATABASE $CONTAINER_DUMP_PATH;
                ;;

                migrate|mg)
                    if [ -z "$DUMP_FILE" ]; then
                        usage "Dump file name unspecified, use flag -F|--dump-file <FILE>";
                    fi
                    if ! $PROJECT_DIR/rctmake dump:restore -F $DUMP_FILE; then
                        docker exec $DB_CONTAINER_NAME /docker-entrypoint-initdb.d/utils/print-data.sh

                        echo Is it ok?
                        echo "What do you want to do with file: $DUMP_PATH  ?";
                        echo "Cancel operation | Replace | As new File";
                        echo  " : [c]|r|n" 
                        read opt;
                        if [[ "$opt" =~ ^r$ ]]; then
                            $PROJECT_DIR/rctmake dump:make -F $DUMP_FILE -Y
                        elif [[ "$opt" =~ ^n$ ]]; then
                            $PROJECT_DIR/rctmake dump:make -F $DUMP_FILE.migrated
                        else 
                            exit 0;
                        fi
                    else
                        echo nothing to do;
                    fi
                ;;

                remove|rm)
                    if [ -z "$DUMP_FIL" ]; then
                        usage "dump file unspecified, use flag -F|--dump-file <FILE>";
                    fi 
                    rm $DUMP_PATH;
                ;;

                export|ex)
                    tar -c -f $PREVIOD_USER_LOC/$DUMPS_ARCHIVE_NAME -C $DUMPS_DIR .;
                ;;

                import|im)
                    tar xvf $PREVIOD_USER_LOC/$DUMPS_ARCHIVE_NAME -C $DUMPS_DIR;
                ;;

                *)
                    incorrect_stage_err $stage;
                ;;
            esac
        ;;
        *)
            incorrect_stage_err $stage
        ;;
    esac

    CURRENT_STAGE_STATUS_CODE=$?
    if [ $CURRENT_STAGE_STATUS_CODE -ne 0 ]; then
        echo "stage $stage ended with code: $CURRENT_STAGE_STATUS_CODE"
        if [ -z $IGNORE_STAGE_ERRORS ]; then
            exit $CURRENT_STAGE_STATUS_CODE;
        fi;
    fi;
done


cd $PREVIOD_USER_LOC;
